# setup -------------------------------------------------------------------

#general
rm(list=ls())
cat("\014")
set.seed(299792458)

library(lubridate)
library(ggplot2)
library(dplyr)
library(tidyr)

# data and variable definition
data <- read.csv("ScanRecords.csv")
data1 <- data
colnames(data1) <- c("Date","Time","ScanTime","PatientType")
nrows <- nrow(data1)

# Date parsing (handles m/d/y, d/m/y, y-m-d, dates-with-time, and Excel numeric dates)
parse_date_any <- function(x) {
  if (inherits(x, "Date")) return(x)
  
  # Excel-style numeric dates
  if (is.numeric(x)) return(as.Date(x, origin = "1899-12-30"))
  
  x <- trimws(as.character(x))
  x <- sub("\\s+.*$", "", x)  # drop any time part (e.g., "8/1/2025 00:00")
  
  d <- suppressWarnings(parse_date_time(
    x,
    orders = c("mdy", "dmy", "ymd", "m/d/Y", "d/m/Y", "Y-m-d", "m-d-Y", "d-m-Y", "m/d/y", "d/m/y", "y-m-d"),
    exact = FALSE
  ))
  as.Date(d)
}

data1$Date_parsed <- parse_date_any(data1$Date)

# If anything still failed, print a few bad values and stop
bad <- which(is.na(data1$Date_parsed))
if (length(bad) > 0) {
  print("Unparsed Date values (first 20):")
  print(unique(as.character(data1$Date))[1:min(20, length(unique(as.character(data1$Date))))])
  print("Examples of failing rows (first 10):")
  print(data1$Date[bad[1:min(10, length(bad))]])
  stop("Some Date values could not be parsed. See printed examples above.")
}

if (any(is.na(data1$Date_parsed))) {
  stop("Some Date values could not be parsed. Inspect ScanRecords.csv Date column.")
}

# Day of month 
data1$day <- as.integer(format(data1$Date_parsed, "%d"))

# Weekday flags 
wd <- weekdays(data1$Date_parsed)
data1$MO <- as.integer(wd == "Monday")
data1$TU <- as.integer(wd == "Tuesday")
data1$WE <- as.integer(wd == "Wednesday")
data1$TH <- as.integer(wd == "Thursday")
data1$FR <- as.integer(wd == "Friday")

# Week-of-month flags (Aug 2025)
# W1: 1,4-8  | W2: 11-15 | W3: 18-22 | W4: 25-29
data1$W1 <- as.integer(data1$day %in% c(1,4,5,6,7,8))
data1$W2 <- as.integer(data1$day %in% c(11,12,13,14,15))
data1$W3 <- as.integer(data1$day %in% c(18,19,20,21,22))
data1$W4 <- as.integer(data1$day %in% c(25,26,27,28,29))

# data3 is the “main” analysis table 
data3 <- data1 %>%
  select(Date, Time, ScanTime, PatientType, MO, TU, WE, TH, FR, W1, W2, W3, W4, day, Date_parsed)

# Convert ScanTime to minutes 
data3$ScanTime <- as.numeric(data3$ScanTime) * 60
data3$Time <- as.numeric(data3$Time)


# Daily frequency table (type1Freq/type2Freq)
g <- c(1,4:8,11:15,18:22,25:29)

type1Freq <- numeric(length(g))
type2Freq <- numeric(length(g))

for (k in seq_along(g)) {
  i <- g[k]
  subset_day <- data3 %>% filter(day == i)
  tab <- table(subset_day$PatientType)
  type1Freq[k] <- if ("Type 1" %in% names(tab)) as.numeric(tab["Type 1"]) else 0
  type2Freq[k] <- if ("Type 2" %in% names(tab)) as.numeric(tab["Type 2"]) else 0
}

data5 <- data.frame(type1Freq, type2Freq) %>%
  mutate(sum = type1Freq + type2Freq,
         ratio = ifelse(type1Freq == 0, NA, type2Freq / type1Freq))

# number of calls per (selected) working day
numberofcalls <- numeric(length(g))
for (k in seq_along(g)) {
  numberofcalls[k] <- nrow(data3 %>% filter(day == g[k]))
}
data5$numberofcalls <- numberofcalls
g<-c(1,4:8,11:15,18:22,25:29)
data5$days<-g

# Correct call.diff (inter-arrival in working hours; ignore outside 08-17)
# computed per PatientType across the whole month
work_gap <- function(date_prev, time_prev, date_next, time_next,
                     day_start = 8, day_end = 17) {
  if (is.na(date_prev) || is.na(time_prev)) return(NA_real_)
  if (date_next == date_prev) {
    return(time_next - time_prev)
  } else {
    # ignore all time outside working hours (including weekends)
    return((day_end - time_prev) + (time_next - day_start))
  }
}

data3 <- data3 %>%
  arrange(PatientType, Date_parsed, Time) %>%
  group_by(PatientType) %>%
  mutate(
    prev_date = lag(Date_parsed),
    prev_time = lag(Time),
    `call.diff` = mapply(work_gap, prev_date, prev_time, Date_parsed, Time)
  ) %>%
  ungroup() %>%
  select(-prev_date, -prev_time)

total9<-vector()
tot9<-vector()
total9[1]<-sum(data3$W1)
total9[2]<-sum(data3$W2)
total9[3]<-sum(data3$W3)
total9[4]<-sum(data3$W4)
tot9[1]<-sum(data3$MO)
tot9[2]<-sum(data3$TU)
tot9[3]<-sum(data3$WE)
tot9[4]<-sum(data3$TH)
tot9[5]<-sum(data3$FR)
data9a<-data.frame(total9)
data9a$w<-c("w1","w2","w3","w4")
data9b<-data.frame(tot9)
data9b$d<-c("MO","TU","WE","TH","FR")

data10w1<-data3%>%filter(W1==1)
data10w2<-data3%>%filter(W2==1)
data10w3<-data3%>%filter(W3==1)
data10w4<-data3%>%filter(W4==1)
data10MO<-data3%>%filter(MO==1)
data10TU<-data3%>%filter(TU==1)
data10WE<-data3%>%filter(WE==1)
data10TH<-data3%>%filter(TH==1)
data10FR<-data3%>%filter(FR==1)

#preliminary investigation
summary(data3)
summary(data5)
summary(data10MO)
summary(data10TU)
summary(data10WE)
summary(data10TH)
summary(data10FR)
summary(data10w1)
summary(data10w2)
summary(data10w3)
summary(data10w4)

# Density + histogram (fixed for new ggplot2: after_stat(density))
ggplot(data3, aes(x = ScanTime)) +
  geom_histogram(aes(y = after_stat(density)), colour="black", fill="steelblue") +
  geom_density(alpha=.2, fill="red") +
  theme_minimal() + xlab("") + ylab("")

ggplot(data3, aes(x = Time)) +
  geom_histogram(aes(y = after_stat(density)), colour="black", fill="steelblue") +
  geom_density(alpha=.2, fill="red") +
  theme_minimal() + xlab("") + ylab("")

ggplot(data5,aes(x=days))+ 
  geom_line(aes(y=type1Freq),color="blue",alpha=0.2, size=1.2)+
  geom_line(aes(y=type2Freq),color="red",alpha=0.2, size=1.2)+
  theme_minimal()+ylab("")+labs(title =)

ggplot(data5,aes(x=sum))+ geom_histogram(color="black", fill="steelblue")

ggplot(data9a, aes(x=w,y = total9))+geom_bar(stat="identity",fill="steelblue")+
  labs(title = )+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))+
  theme(panel.background = element_rect(fill='white'))+ylab("number of calls")+
  scale_fill_continuous()

ggplot(data9b, aes(x=d,y = tot9))+geom_bar(stat="identity",fill="steelblue")+
  labs(title = )+ theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))+
  theme(panel.background = element_rect(fill='white'))+ylab("number of calls")+
  scale_fill_continuous()


# analysis for types 1 & 2
# (removed invalid labs(title =)+ which would crash)
ggplot(data3, aes(x=ScanTime)) +
  geom_histogram(color="black", fill="steelblue") +
  facet_grid(PatientType ~ .) +
  xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=Time)) +
  geom_histogram(color="black", fill="steelblue") +
  facet_grid(PatientType ~ .) +
  xlab("") + ylab("") + theme_minimal()

ggplot(subset(data3, !is.na(`call.diff`)), aes(x = `call.diff`)) +
  geom_histogram(color="black", fill="steelblue") +
  facet_grid(PatientType ~ .) +
  xlab("") + ylab("") + theme_minimal()

# ----------------------------
# analysis for weeks 1-4 of August
# ----------------------------
ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W1 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(W1 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(subset(data3, !is.na(`call.diff`)), aes(x = `call.diff`)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W1 ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W2 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(W2 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(subset(data3, !is.na(`call.diff`)), aes(x = `call.diff`)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W2 ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W3 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(W3 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(subset(data3, !is.na(`call.diff`)), aes(x = `call.diff`)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W3 ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W4 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(W4 ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(subset(data3, !is.na(`call.diff`)), aes(x = `call.diff`)) + geom_histogram(color="black", fill="steelblue") + facet_grid(W4 ~ .) + xlab("") + ylab("") + theme_minimal()

# ----------------------------
# analysis for workdays MO-FR of August
# ----------------------------
ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(MO ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(MO ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(TU ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(TU ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(WE ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(WE ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(TH ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(TH ~ .) + xlab("") + ylab("") + theme_minimal()

ggplot(data3, aes(x=ScanTime)) + geom_histogram(color="black", fill="steelblue") + facet_grid(FR ~ .) + xlab("") + ylab("") + theme_minimal()
ggplot(data3, aes(x=Time))     + geom_histogram(color="black", fill="steelblue") + facet_grid(FR ~ .) + xlab("") + ylab("") + theme_minimal()

#functions
Bootstrap.moments.NP<-function(B,x,alpha){
  q1<-1:B
  q2<-1:B
  q3<-1:B
  q4<-1:B
  q5<-1:B
  q6<-1:B
  q7<-1:B
  nrows<-length(x)
  for(i in 1:B){
    boot<-sample.int(nrows,size = nrows,replace = T)
    boot<-x[boot]
    S<-(1/nrows)*sum(((boot-mean(boot,na.rm=T))/sd(boot))^3,na.rm=T)
    K<-(1/nrows)*sum(((boot-mean(boot,na.rm=T))/sd(boot))^4,na.rm=T)
    q1[i]<-mean(boot,na.rm=T)
    q2[i]<-sd(boot,na.rm=T)
    q3[i]<-S
    q4[i]<-K
    q5[i]<-median(boot,na.rm=T)
    q6[i]<-quantile(boot,0.25,na.rm=T)
    q7[i]<-quantile(boot,0.75,na.rm=T)
  }
  #statistics
  b1<-round(mean(x,na.rm=T),4)
  b2<-round(var(x,na.rm=T)^0.5,4)
  s1<-((sum((x-mean(x,na.rm=T))^2,na.rm=T))/(nrows-1))^0.5
  se1<-s1*((nrows-1)/nrows)^0.5
  b3<-round((1/nrows)*sum(((x-mean(x,na.rm=T))/se1)^3,na.rm=T),4)
  b4<-round((1/nrows)*sum(((x-mean(x,na.rm=T))/se1)^4,na.rm=T),4)
  JB<-nrows/6*(b3^2+0.25*(b4-3)^2)
  P3<-round(pchisq(JB,df=2 ,F,F),4)
  b5<-round(min(x,na.rm=T),4)
  b6<-round(max(x,na.rm=T),4)
  b7<-round(median(x,na.rm=T),4)
  b8<-round(quantile(x,0.25,na.rm=T),4)
  b9<-round(quantile(x,0.75,na.rm=T),4)
  #confidence interval
  qsort1<-sort(q1,na.last = T)
  qsort2<-sort(q2,na.last = T)
  qsort3<-sort(q3,na.last = T)
  qsort4<-sort(q4,na.last = T)
  qsort5<-sort(q5,na.last = T)
  qsort6<-sort(q6,na.last = T)
  qsort7<-sort(q7,na.last = T)
  #two sided interval mean
  L1<-round(quantile(qsort1,alpha/2,na.rm=T),4)
  U1<-round(quantile(qsort1,1-alpha/2,na.rm=T),4)
  #two sided interval standard deviation
  L2<-round(quantile(qsort2,alpha/2,na.rm=T),4)
  U2<-round(quantile(qsort2,1-alpha/2,na.rm=T),4)
  #two sided interval skewness
  L3<-round(quantile(qsort3,alpha/2,na.rm=T),4)
  U3<-round(quantile(qsort3,1-alpha/2,na.rm=T),4)
  #two sided interval kurtosis
  L4<-round(quantile(qsort4,alpha/2,na.rm=T),4)
  U4<-round(quantile(qsort4,1-alpha/2,na.rm=T),4)
  #two sided interval median q-25 and q-75
  L5<-round(quantile(qsort5,alpha/2,na.rm=T),4)
  U5<-round(quantile(qsort5,1-alpha/2,na.rm=T),4)
  L6<-round(quantile(qsort6,alpha/2,na.rm=T),4)
  U6<-round(quantile(qsort6,1-alpha/2,na.rm=T),4)
  L7<-round(quantile(qsort7,alpha/2,na.rm=T),4)
  U7<-round(quantile(qsort7,1-alpha/2,na.rm=T),4)
  # results
  print("output: bootstrap confidence interval of moments non parametric")
  print("")
  print(paste("the mean of the data is:", b1))
  print(paste("the standard deviation of the data is:", b2))
  print(paste("the skewness of the data is:", b3))
  print(paste("the kurtosis of the data is:", b4))
  print(paste("the minimum of the data is:", b5))
  print(paste("the maximum of the data is:", b6))
  print(paste("the median of the data is:", b7))
  print(paste("the 25% percentile of the data is:", b8))
  print(paste("the 75% percentile of the data is:", b9))
  print("")
  print(paste("The P-value that the series is normally distributed:",P3))
  print("")
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the mean is: [",L1,",",U1,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the standard deviation is : [",L2,",",U2,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the skewness is: [",L3,",",U3,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the kurtosis is: [",L4,",",U4,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the median is: [",L5,",",U5,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 25-percentile is: [",L6,",",U6,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 75-percentile is: [",L7,",",U7,"]"))
}

Bootstrap.moments.norm<-function(B,x,alpha){
  q1<-1:B
  q2<-1:B
  q5<-1:B
  q6<-1:B
  q7<-1:B
  nrows<-length(x)
  for(i in 1:B){
    #parametric bootstrap with normality
    boot<-rnorm(nrows,mean(x),sd(x))
    q1[i]<-mean(boot)
    q2[i]<-sd(boot)
    q5[i]<-median(boot)
    q6[i]<-quantile(boot,0.25)
    q7[i]<-quantile(boot,0.75)
  }
  #statistics
  b1<-round(mean(x),4)
  b2<-round(var(x)^0.5,4)
  s1<-((sum((x-mean(x))^2))/(nrows-1))^0.5
  se1<-s1*((nrows-1)/nrows)^0.5
  b3<-round((1/nrows)*sum(((x-mean(x))/se1)^3),4)
  b4<-round((1/nrows)*sum(((x-mean(x))/se1)^4),4)
  JB<-nrows/6*(b3^2+0.25*(b4-3)^2)
  P3<-round(pchisq(JB,df=2 ,F,F),4)
  b5<-round(min(x),4)
  b6<-round(max(x),4)
  b7<-round(median(x),4)
  b8<-round(quantile(x,0.25),4)
  b9<-round(quantile(x,0.75),4)
  #confidence interval
  qsort1<-sort(q1,na.last = T)
  qsort2<-sort(q2,na.last = T)
  qsort5<-sort(q5,na.last = T)
  qsort6<-sort(q6,na.last = T)
  qsort7<-sort(q7,na.last = T)
  #two sided interval mean
  L1<-round(quantile(qsort1,alpha/2),4)
  U1<-round(quantile(qsort1,1-alpha/2),4)
  #two sided interval standard deviation
  L2<-round(quantile(qsort2,alpha/2),4)
  U2<-round(quantile(qsort2,1-alpha/2),4)
  #two sided interval median q-25 and q-75
  L5<-round(quantile(qsort5,alpha/2),4)
  U5<-round(quantile(qsort5,1-alpha/2),4)
  L6<-round(quantile(qsort6,alpha/2),4)
  U6<-round(quantile(qsort6,1-alpha/2),4)
  L7<-round(quantile(qsort7,alpha/2),4)
  U7<-round(quantile(qsort7,1-alpha/2),4)
  # results
  print("output: bootstrap confidence interval of moments parametric normal")
  print("")
  print(paste("the mean of the data is:", b1))
  print(paste("the standard deviation of the data is:", b2))
  print(paste("the minimum of the data is:", b5))
  print(paste("the maximum of the data is:", b6))
  print(paste("the median of the data is:", b7))
  print(paste("the 25% percentile of the data is:", b8))
  print(paste("the 75% percentile of the data is:", b9))
  print("")
  print(paste("The P-value that the series is normally distributed:",P3))
  print("")
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the mean is: [",L1,",",U1,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the standard deviation is : [",L2,",",U2,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the median is: [",L5,",",U5,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 25-percentile is: [",L6,",",U6,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 75-percentile is: [",L7,",",U7,"]"))
}

Bootstrap.moments.poiss<-function(B,x,alpha){
  q1<-1:B
  q2<-1:B
  q5<-1:B
  q6<-1:B
  q7<-1:B
  nrows<-length(x)
  for(i in 1:B){
    #parametric bootstrap with poisson
    boot<-rpois(nrows,mean(x))
    q1[i]<-mean(boot)
    q2[i]<-sd(boot)
    q5[i]<-median(boot)
    q6[i]<-quantile(boot,0.25)
    q7[i]<-quantile(boot,0.75)
  }
  #statistics
  b1<-round(mean(x),4)
  b2<-round(var(x)^0.5,4)
  s1<-((sum((x-mean(x))^2))/(nrows-1))^0.5
  se1<-s1*((nrows-1)/nrows)^0.5
  b3<-round((1/nrows)*sum(((x-mean(x))/se1)^3),4)
  b4<-round((1/nrows)*sum(((x-mean(x))/se1)^4),4)
  JB<-nrows/6*(b3^2+0.25*(b4-3)^2)
  P3<-round(pchisq(JB,df=2 ,F,F),4)
  b5<-round(min(x),4)
  b6<-round(max(x),4)
  b7<-round(median(x),4)
  b8<-round(quantile(x,0.25),4)
  b9<-round(quantile(x,0.75),4)
  #confidence interval
  qsort1<-sort(q1,na.last = T)
  qsort2<-sort(q2,na.last = T)
  qsort5<-sort(q5,na.last = T)
  qsort6<-sort(q6,na.last = T)
  qsort7<-sort(q7,na.last = T)
  #two sided interval mean
  L1<-round(quantile(qsort1,alpha/2),4)
  U1<-round(quantile(qsort1,1-alpha/2),4)
  #two sided interval standard deviation
  L2<-round(quantile(qsort2,alpha/2),4)
  U2<-round(quantile(qsort2,1-alpha/2),4)
  #two sided interval median q-25 and q-75
  L5<-round(quantile(qsort5,alpha/2),4)
  U5<-round(quantile(qsort5,1-alpha/2),4)
  L6<-round(quantile(qsort6,alpha/2),4)
  U6<-round(quantile(qsort6,1-alpha/2),4)
  L7<-round(quantile(qsort7,alpha/2),4)
  U7<-round(quantile(qsort7,1-alpha/2),4)
  # results
  print("output: bootstrap confidence interval of moments parametric poiss")
  print("")
  print(paste("the mean of the data is:", b1))
  print(paste("the standard deviation of the data is:", b2))
  print(paste("the minimum of the data is:", b5))
  print(paste("the maximum of the data is:", b6))
  print(paste("the median of the data is:", b7))
  print(paste("the 25% percentile of the data is:", b8))
  print(paste("the 75% percentile of the data is:", b9))
  print("")
  print(paste("The P-value that the series is normally distributed:",P3))
  print("")
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the mean is: [",L1,",",U1,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the standard deviation is : [",L2,",",U2,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the median is: [",L5,",",U5,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 25-percentile is: [",L6,",",U6,"]"))
  print(paste0("a ",(1-alpha)*100,"% bootstrapped two sided confidance interval for the 75-percentile is: [",L7,",",U7,"]"))
}

Monte.carlo.sim.norm<-function(B,sim,sample,alpha){
  r.simple.mean<-rep(0,sim)
  r.method.mean<-rep(0,sim)
  r.simple.sd<-rep(0,sim)
  r.method.sd<-rep(0,sim)
  r.simple.S<-rep(0,sim)
  r.method.S<-rep(0,sim)
  r.simple.K<-rep(0,sim)
  r.method.K<-rep(0,sim)
  r.simple.median<-rep(0,sim)
  r.method.median<-rep(0,sim)
  #simulate data
  
  for(i in 1:sim){
    x<-rnorm(sample,0,1)
    nrows<-length(x)
    #statistics
    b1<-mean(x)
    b2<-var(x)^0.5
    s1<-((sum((x-mean(x))^2))/(nrows-1))^0.5
    se1<-s1*((nrows-1)/nrows)^0.5
    b3<-(1/nrows)*sum(((x-mean(x))/se1)^3)
    b4<-(1/nrows)*sum(((x-mean(x))/se1)^4)
    b5<-median(x)
    
    #confidence intervals
    L1.S<-b1-qnorm(1-alpha/2)*b2/(nrows)^0.5
    U1.S<-b1+qnorm(1-alpha/2)*b2/(nrows)^0.5
    L2.S<-b2*((nrows-1)/qchisq(1-alpha/2,nrows-1))^0.5
    U2.S<-b2*((nrows-1)/qchisq(alpha/2,nrows-1))^0.5
    L3.S<-b3-qnorm(1-alpha/2)*((6*nrows*(nrows-1))/((nrows-2)*(nrows+1)*(nrows+3)))^0.5/(nrows)^0.5
    U3.S<-b3+qnorm(1-alpha/2)*((6*nrows*(nrows-1))/((nrows-2)*(nrows+1)*(nrows+3)))^0.5/(nrows)^0.5
    L4.S<-b4-qnorm(1-alpha/2)*((24*nrows*(nrows-1)^2)/((nrows-3)*(nrows-2)*(nrows+3)*(nrows+5)))^0.5/(nrows)^0.5
    U4.S<-b4+qnorm(1-alpha/2)*((24*nrows*(nrows-1)^2)/((nrows-3)*(nrows-2)*(nrows+3)*(nrows+5)))^0.5/(nrows)^0.5
    L5.S<-b5-qnorm(1-alpha/2)/(2*dnorm(0)*(nrows)^0.5)
    U5.S<-b5+qnorm(1-alpha/2)/(2*dnorm(0)*(nrows)^0.5)
    
    if (0 >=L1.S  && 0 <= U1.S) {
      r.simple.mean[i]<-1
    }
    if (1 >=L2.S  && 1 <= U2.S) {
      r.simple.sd[i]<-1
    }
    if (0 >=L3.S  && 0 <= U3.S) {
      r.simple.S[i]<-1
    }
    if (3 >=L4.S  && 3 <= U4.S) {
      r.simple.K[i]<-1
    }
    if (0 >=L5.S  && 0 <= U5.S) {
      r.simple.median[i]<-1
    }
    #bootstrap method
    q1<-1:B
    q2<-1:B
    q3<-1:B
    q4<-1:B
    q5<-1:B
    nrows<-length(x)
    for(j in 1:B){
      boot<-sample.int(nrows,size = nrows,replace = T)
      boot<-x[boot]
      S<-(1/nrows)*sum(((boot-mean(boot))/sd(boot))^3)
      K<-(1/nrows)*sum(((boot-mean(boot))/sd(boot))^4)
      q1[j]<-mean(boot)
      q2[j]<-sd(boot)
      q3[j]<-S
      q4[j]<-K
      q5[j]<-median(boot)
    }
    qsort1<-sort(q1,na.last = T)
    qsort2<-sort(q2,na.last = T)
    qsort3<-sort(q3,na.last = T)
    qsort4<-sort(q4,na.last = T)
    qsort5<-sort(q5,na.last = T)
    #two sided interval mean
    L1.B<-quantile(qsort1,alpha/2)
    U1.B<-quantile(qsort1,1-alpha/2)
    #two sided interval standard deviation
    L2.B<-quantile(qsort2,alpha/2)
    U2.B<-quantile(qsort2,1-alpha/2)
    #two sided interval skewness
    L3.B<-quantile(qsort3,alpha/2)
    U3.B<-quantile(qsort3,1-alpha/2)
    #two sided interval kurtosis
    L4.B<-quantile(qsort4,alpha/2)
    U4.B<-quantile(qsort4,1-alpha/2)
    #two sided interval median q-25 and q-75
    L5.B<-quantile(qsort5,alpha/2)
    U5.B<-quantile(qsort5,1-alpha/2)
    if (0 >=L1.B  && 0 <= U1.B) {
      r.method.mean[i]<-1
    }
    if (1 >=L2.B  && 1 <= U2.B) {
      r.method.sd[i]<-1
    }
    if (0 >=L3.B  && 0 <= U3.B) {
      r.method.S[i]<-1
    }
    if (3 >=L4.B  && 3 <= U4.B) {
      r.method.K[i]<-1
    }
    if (0 >=L5.B  && 0 <= U5.B) {
      r.method.median[i]<-1
    }
  }
  ERF.S.mean<-1-round(mean(r.simple.mean),4)
  ERF.B.mean<-1-round(mean(r.method.mean),4)
  ERF.S.SD<-1-round(mean(r.simple.sd),4)
  ERF.B.SD<-1-round(mean(r.method.sd),4)
  ERF.S.S<-1-round(mean(r.simple.S),4)
  ERF.B.S<-1-round(mean(r.method.S),4)
  ERF.S.K<-1-round(mean(r.simple.K),4)
  ERF.B.K<-1-round(mean(r.method.K),4)
  ERF.S.median<-1-round(mean(r.simple.median),4)
  ERF.B.median<-1-round(mean(r.method.median),4)
  # results
  print("output: comparison empirical rejection Bootstrap and normality")
  print("")
  print(paste("the empirical rejection freq. for the mean using Bootstrap is:",ERF.B.mean))
  print(paste("the empirical rejection freq. for the mean using normality is:",ERF.S.mean))
  print("")
  print(paste("the empirical rejection freq. for the standard deviation using Bootstrap is:",ERF.B.SD))
  print(paste("the empirical rejection freq. for the standard deviation using normality is:",ERF.S.SD))
  print("")
  print(paste("the empirical rejection freq. for the skewness using Bootstrap is:",ERF.B.S))
  print(paste("the empirical rejection freq. for the skewness using normality is:",ERF.S.S))
  print("")
  print(paste("the empirical rejection freq. for the kurtosis using Bootstrap is:",ERF.B.K))
  print(paste("the empirical rejection freq. for the kurtosis using normality is:",ERF.S.K))
  print("")
  print(paste("the empirical rejection freq. for the median using Bootstrap is:",ERF.S.median))
  print(paste("the empirical rejection freq. for the median using normality is:",ERF.B.median))
  print("")
}

Monte.carlo.sim.pois<-function(B,sim,sample,alpha){
  r.simple.mean<-rep(0,sim)
  r.method.mean<-rep(0,sim)
  r.simple.mean2<-rep(0,sim)
  r.simple.sd<-rep(0,sim)
  r.simple.sd2<-rep(0,sim)
  r.method.sd<-rep(0,sim)
  r.simple.S<-rep(0,sim)
  r.method.S<-rep(0,sim)
  r.simple.K<-rep(0,sim)
  r.method.K<-rep(0,sim)
  r.simple.median<-rep(0,sim)
  r.method.median<-rep(0,sim)
  #simulate data
  
  for(i in 1:sim){
    x<-rpois(sample,1)
    nrows<-length(x)
    #statistics
    b1<-mean(x)
    b2<-var(x)^0.5
    s1<-((sum((x-mean(x))^2))/(nrows-1))^0.5
    se1<-s1*((nrows-1)/nrows)^0.5
    b3<-(1/nrows)*sum(((x-mean(x))/se1)^3)
    b4<-(1/nrows)*sum(((x-mean(x))/se1)^4)
    b5<-median(x)
    
    #confidence intervals
    L1.S<-b1-qnorm(1-alpha/2)*b2/(nrows)^0.5
    U1.S<-b1+qnorm(1-alpha/2)*b2/(nrows)^0.5
    L1.S2<-qgamma(alpha/2,sum(x),1)/nrows
    U1.S2<-qgamma(1-alpha/2,sum(x)+1,1)/nrows
    L2.S<-b2*((nrows-1)/qchisq(1-alpha/2,nrows-1))^0.5
    U2.S<-b2*((nrows-1)/qchisq(alpha/2,nrows-1))^0.5
    L2.S2<-(qgamma(alpha/2,sum(x),1)/nrows)^0.5
    U2.S2<-(qgamma(1-alpha/2,sum(x)+1,1)/nrows)^0.5
    L3.S<-b3-qnorm(1-alpha/2)*((6*nrows*(nrows-1))/((nrows-2)*(nrows+1)*(nrows+3)))^0.5/(nrows)^0.5
    U3.S<-b3+qnorm(1-alpha/2)*((6*nrows*(nrows-1))/((nrows-2)*(nrows+1)*(nrows+3)))^0.5/(nrows)^0.5
    L4.S<-b4-qnorm(1-alpha/2)*((24*nrows*(nrows-1)^2)/((nrows-3)*(nrows-2)*(nrows+3)*(nrows+5)))^0.5/(nrows)^0.5
    U4.S<-b4+qnorm(1-alpha/2)*((24*nrows*(nrows-1)^2)/((nrows-3)*(nrows-2)*(nrows+3)*(nrows+5)))^0.5/(nrows)^0.5
    L5.S<-b5-qnorm(1-alpha/2)/(2*dnorm(0)*(nrows)^0.5)
    U5.S<-b5+qnorm(1-alpha/2)/(2*dnorm(0)*(nrows)^0.5)
    
    if (1 >=L1.S  && 1 <= U1.S) {
      r.simple.mean[i]<-1
    }
    if (1 >=L1.S2  && 1 <= U1.S2) {
      r.simple.mean2[i]<-1
    }
    if (1 >=L2.S  && 1 <= U2.S) {
      r.simple.sd[i]<-1
    }
    if (1 >=L2.S2  && 1 <= U2.S2) {
      r.simple.sd2[i]<-1
    }
    if (1 >=L3.S  && 1 <= U3.S) {
      r.simple.S[i]<-1
    }
    if (4 >=L4.S  && 4 <= U4.S) {
      r.simple.K[i]<-1
    }
    if (1 >=L5.S  && 1 <= U5.S) {
      r.simple.median[i]<-1
    }
    #bootstrap method
    q1<-1:B
    q2<-1:B
    q3<-1:B
    q4<-1:B
    q5<-1:B
    nrows<-length(x)
    for(j in 1:B){
      boot<-sample.int(nrows,size = nrows,replace = T)
      boot<-x[boot]
      S<-(1/nrows)*sum(((boot-mean(boot))/sd(boot))^3)
      K<-(1/nrows)*sum(((boot-mean(boot))/sd(boot))^4)
      q1[j]<-mean(boot)
      q2[j]<-sd(boot)
      q3[j]<-S
      q4[j]<-K
      q5[j]<-median(boot)
    }
    qsort1<-sort(q1,na.last = T)
    qsort2<-sort(q2,na.last = T)
    qsort3<-sort(q3,na.last = T)
    qsort4<-sort(q4,na.last = T)
    qsort5<-sort(q5,na.last = T)
    #two sided interval mean
    L1.B<-quantile(qsort1,alpha/2)
    U1.B<-quantile(qsort1,1-alpha/2)
    #two sided interval standard deviation
    L2.B<-quantile(qsort2,alpha/2)
    U2.B<-quantile(qsort2,1-alpha/2)
    #two sided interval skewness
    L3.B<-quantile(qsort3,alpha/2)
    U3.B<-quantile(qsort3,1-alpha/2)
    #two sided interval kurtosis
    L4.B<-quantile(qsort4,alpha/2)
    U4.B<-quantile(qsort4,1-alpha/2)
    #two sided interval median q-25 and q-75
    L5.B<-quantile(qsort5,alpha/2)
    U5.B<-quantile(qsort5,1-alpha/2)
    if (1 >=L1.B  && 1 <= U1.B) {
      r.method.mean[i]<-1
    }
    if (1 >=L2.B  && 1 <= U2.B) {
      r.method.sd[i]<-1
    }
    if (1 >=L3.B  && 1 <= U3.B) {
      r.method.S[i]<-1
    }
    if (4 >=L4.B  && 4 <= U4.B) {
      r.method.K[i]<-1
    }
    if (1 >=L5.B  && 1 <= U5.B) {
      r.method.median[i]<-1
    }
  }
  ERF.S.mean<-1-round(mean(r.simple.mean),4)
  ERF.B.mean<-1-round(mean(r.method.mean),4)
  ERF.S.mean2<-1-round(mean(r.simple.mean2),4)
  ERF.S.SD<-1-round(mean(r.simple.sd),4)
  ERF.B.SD<-1-round(mean(r.method.sd),4)
  ERF.S.SD2<-1-round(mean(r.simple.sd2),4)
  ERF.S.S<-1-round(mean(r.simple.S),4)
  ERF.B.S<-1-round(mean(r.method.S),4)
  ERF.S.K<-1-round(mean(r.simple.K),4)
  ERF.B.K<-1-round(mean(r.method.K),4)
  ERF.S.median<-1-round(mean(r.simple.median),4)
  ERF.B.median<-1-round(mean(r.method.median),4)
  # results
  print("output: comparison empirical rejection Bootstrap and normality")
  print("")
  print(paste("the empirical rejection freq. for the mean using Bootstrap is:",ERF.B.mean))
  print(paste("the empirical rejection freq. for the mean using normality is:",ERF.S.mean))
  print(paste("the empirical rejection freq. for the mean using gamma is:",ERF.S.mean2))
  print("")
  print(paste("the empirical rejection freq. for the standard deviation using Bootstrap is:",ERF.B.SD))
  print(paste("the empirical rejection freq. for the standard deviation using normality is:",ERF.S.SD))
  print(paste("the empirical rejection freq. for the standard deviation using gamma is:",ERF.S.SD2))
  print("")
  print(paste("the empirical rejection freq. for the skewness using Bootstrap is:",ERF.B.S))
  print(paste("the empirical rejection freq. for the skewness using normality is:",ERF.S.S))
  print("")
  print(paste("the empirical rejection freq. for the kurtosis using Bootstrap is:",ERF.B.K))
  print(paste("the empirical rejection freq. for the kurtosis using normality is:",ERF.S.K))
  print("")
  print(paste("the empirical rejection freq. for the median using Bootstrap is:",ERF.S.median))
  print(paste("the empirical rejection freq. for the median using normality is:",ERF.B.median))
  print("")
}

# Analysis Treatment 1:duration and number of patients ----------------------------------------------------
data4<-data3%>%filter(PatientType=="Type 1")
data4W1<-data4%>%filter(W1==1)
data4W2<-data4%>%filter(W2==1)
data4W3<-data4%>%filter(W3==1)
data4W4<-data4%>%filter(W4==1)
data4MO<-data4%>%filter(MO==1)
data4TU<-data4%>%filter(TU==1)
data4WE<-data4%>%filter(WE==1)
data4TH<-data4%>%filter(TH==1)
data4FR<-data4%>%filter(FR==1)

#parametric duration scan
#full sample
Bootstrap.moments.norm(9999,data4$ScanTime,0.05)
#weeks
Bootstrap.moments.norm(9999,data4W1$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4W2$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4W3$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4W4$ScanTime,0.05)
#days
Bootstrap.moments.norm(9999,data4MO$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4TU$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4WE$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4TH$ScanTime,0.05)
Bootstrap.moments.norm(9999,data4FR$ScanTime,0.05)

#parametric number of patients
patients<-data5$type1Freq
Bootstrap.moments.poiss(9999,patients,0.05)

# Analysis Treatment 2:duration and number of patients ----------------------------------------------------
data6<-data3%>%filter(PatientType=="Type 2")
data6W1<-data6%>%filter(W1==1)
data6W2<-data6%>%filter(W2==1)
data6W3<-data6%>%filter(W3==1)
data6W4<-data6%>%filter(W4==1)
data6MO<-data6%>%filter(MO==1)
data6TU<-data6%>%filter(TU==1)
data6WE<-data6%>%filter(WE==1)
data6TH<-data6%>%filter(TH==1)
data6FR<-data6%>%filter(FR==1)

#non parametric duration scan
#full sample
Bootstrap.moments.NP(9999,data6$ScanTime,0.05)
#weeks
Bootstrap.moments.NP(9999,data6W1$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6W2$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6W3$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6W4$ScanTime,0.05)
#days
Bootstrap.moments.NP(9999,data6MO$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6TU$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6WE$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6TH$ScanTime,0.05)
Bootstrap.moments.NP(9999,data6FR$ScanTime,0.05)

#non parametric number of patients
patients<-data5$type2Freq
Bootstrap.moments.NP(9999,patients,0.05)
#parametric number of patients
Bootstrap.moments.poiss(9999,patients,0.05)

# Analysis varias----------------------------------------------------
# ratio of number of patients daily
Bootstrap.moments.NP(9999,data5$ratio,0.05)
# number of calls every day
Bootstrap.moments.NP(9999,data5$numberofcalls,0.05)
# call frequency
#full sample
Bootstrap.moments.NP(9999,data6$call.diff,0.05)
#weeks
Bootstrap.moments.NP(9999,data6W1$call.diff,0.05)
Bootstrap.moments.NP(9999,data6W2$call.diff,0.05)
Bootstrap.moments.NP(9999,data6W3$call.diff,0.05)
Bootstrap.moments.NP(9999,data6W4$call.diff,0.05)
#days
Bootstrap.moments.NP(9999,data6MO$call.diff,0.05)
Bootstrap.moments.NP(9999,data6TU$call.diff,0.05)
Bootstrap.moments.NP(9999,data6WE$call.diff,0.05)
Bootstrap.moments.NP(9999,data6TH$call.diff,0.05)
Bootstrap.moments.NP(9999,data6FR$call.diff,0.05)  
#full sample
Bootstrap.moments.NP(9999,data4$call.diff,0.05)
#weeks
Bootstrap.moments.NP(9999,data4W1$call.diff,0.05)
Bootstrap.moments.NP(9999,data4W2$call.diff,0.05)
Bootstrap.moments.NP(9999,data4W3$call.diff,0.05)
Bootstrap.moments.NP(9999,data4W4$call.diff,0.05)
#days
Bootstrap.moments.NP(9999,data4MO$call.diff,0.05)
Bootstrap.moments.NP(9999,data4TU$call.diff,0.05)
Bootstrap.moments.NP(9999,data4WE$call.diff,0.05)
Bootstrap.moments.NP(9999,data4TH$call.diff,0.05)
Bootstrap.moments.NP(9999,data4FR$call.diff,0.05)

# monte-carlo study non-parametric methods used treatment 2 -------------------------------------------

#under normality of data
Monte.carlo.sim.norm(B = 999, sim = 200, sample = 50, alpha = 0.05)
#under poisson(1) of data
Monte.carlo.sim.pois(B = 999, sim = 200, sample = 50, alpha = 0.05)


# ============================================================
# PART 2 — SCHEDULING SIMULATION
# ============================================================

# ============================================================
# MRI Scheduling Simulation — Old vs New Policy
# Slot lengths: Type 1 = 30 min, Type 2 = 54 min
# ============================================================

rm(list=ls())
set.seed(299792458)

suppressPackageStartupMessages({
  library(dplyr)
  library(lubridate)
})

# -----------------------------
# USER SETTINGS
# -----------------------------
CSV_PATH <- "ScanRecords.csv"

SLOT_T1 <- 30  # minutes
SLOT_T2 <- 54  # minutes

DAY_START <- 8 * 60   # 08:00 in minutes
DAY_END   <- 17 * 60  # 17:00 in minutes
DAY_LEN   <- DAY_END - DAY_START # 540

N_REP <- 2000     
BUFFER_DAYS <- 30 # extra working days so everyone gets scheduled

# -----------------------------
# 1) LOAD DATA + ESTIMATE INPUTS
# -----------------------------
data <- read.csv(CSV_PATH)
stopifnot(all(c("Date","Time","Duration","PatientType") %in% names(data)))

data1 <- data %>%
  rename(ScanTime = Duration) %>%
  mutate(
    # robust parse (handles m/d/y, d/m/y, y-m-d, etc.)
    Date_parsed = as.Date(parse_date_time(as.character(Date),
                                          orders = c("mdy","dmy","ymd","m/d/Y","d/m/Y","Y-m-d"),
                                          exact = FALSE)),
    Time = as.numeric(Time),
    ScanTime = as.numeric(ScanTime) * 60 # convert to minutes (matches your analysis)
  )

if (any(is.na(data1$Date_parsed))) {
  bad <- unique(data$Date[is.na(data1$Date_parsed)])
  print("Unparsed Date examples:")
  print(head(bad, 20))
  stop("Date parsing failed for some rows. Fix Date format in CSV or add another order.")
}

# Workdays in the dataset (Mon-Fri)
workdays <- data1 %>%
  distinct(Date_parsed) %>%
  filter(!(weekdays(Date_parsed) %in% c("Saturday","Sunday"))) %>%
  arrange(Date_parsed)

n_workdays <- nrow(workdays)
if (n_workdays < 5) stop("Too few workdays detected — check Date parsing.")

# Split types
data_T1 <- data1 %>% filter(PatientType == "Type 1")
data_T2 <- data1 %>% filter(PatientType == "Type 2")

if (nrow(data_T1) < 30 || nrow(data_T2) < 30) {
  warning("Low sample size for one of the types; simulation will still run but uncertainty increases.")
}

# Type 1 scan-time parameters (Normal)
mu1 <- mean(data_T1$ScanTime, na.rm = TRUE)
sd1 <- sd(data_T1$ScanTime, na.rm = TRUE)

# Type 2 scan-time empirical sample (nonparametric resampling)
t2_emp <- data_T2$ScanTime
t2_emp <- t2_emp[is.finite(t2_emp) & t2_emp > 0]
if (length(t2_emp) < 20) stop("Too few valid Type 2 scan times to resample.")

# Arrival rates per WORKDAY from dataset
# Count calls per day by type
daily_counts <- data1 %>%
  filter(!(weekdays(Date_parsed) %in% c("Saturday","Sunday"))) %>%
  count(Date_parsed, PatientType, name = "n") %>%
  tidyr::complete(Date_parsed = unique(workdays$Date_parsed),
                  PatientType = c("Type 1","Type 2"),
                  fill = list(n = 0)) %>%
  arrange(Date_parsed, PatientType)

lambda1 <- mean(daily_counts$n[daily_counts$PatientType=="Type 1"])
lambda2 <- mean(daily_counts$n[daily_counts$PatientType=="Type 2"])

cat("Estimated inputs from CSV:\n")
cat(sprintf("Type 1 scan time Normal(mu=%.3f, sd=%.3f) minutes\n", mu1, sd1))
cat(sprintf("Type 1 calls/day lambda1 = %.3f\n", lambda1))
cat(sprintf("Type 2 calls/day lambda2 = %.3f\n", lambda2))
cat(sprintf("Workdays in dataset = %d\n\n", n_workdays))

# -----------------------------
# 2) HELPERS
# -----------------------------

# Generate call arrivals within a workday: N ~ Poisson(lambda), times uniform in [08:00,17:00)
gen_calls_one_day <- function(day_index, lambda, type_label) {
  n <- rpois(1, lambda)
  if (n == 0) return(NULL)
  times <- runif(n, min = DAY_START, max = DAY_END) # minutes
  tibble(
    call_day = day_index,
    call_time = times,
    PatientType = type_label
  ) %>% arrange(call_time)
}

# Create a list of workdays: original month + buffer days (working days only)
make_workday_calendar <- function(start_date, n_main, buffer) {
  # generate enough calendar days then filter to Mon-Fri
  all_days <- seq.Date(from = start_date, by = "day", length.out = (n_main + buffer) * 2)
  wd <- all_days[!(weekdays(all_days) %in% c("Saturday","Sunday"))]
  wd[1:(n_main + buffer)]
}

# Planned schedule structure: per day, per machine, store planned_end (minutes-from-08:00) and appointments
init_schedule <- function(n_days_total) {
  # For each day and each machine: planned_end counts minutes from DAY_START
  # Also store vector of patient types (for later duration draws)
  list(
    m1_end = rep(0, n_days_total),
    m2_end = rep(0, n_days_total),
    m1_types = vector("list", n_days_total),
    m2_types = vector("list", n_days_total),
    m1_slots = vector("list", n_days_total), # store planned slot lengths for utilization/balance
    m2_slots = vector("list", n_days_total)
  )
}

slot_len_for_type <- function(pt) ifelse(pt == "Type 1", SLOT_T1, SLOT_T2)

# Find earliest feasible (day, machine) starting from earliest_day
# policy = "old" restricts machines by type, "new" allows both
find_earliest_slot <- function(sch, earliest_day, pt, policy) {
  L <- slot_len_for_type(pt)
  
  if (policy == "old") {
    # fixed machine by type
    machine <- if (pt == "Type 1") "m1" else "m2"
    for (d in earliest_day:length(sch$m1_end)) {
      if (machine == "m1") {
        if (sch$m1_end[d] + L <= DAY_LEN) return(list(day=d, machine="m1"))
      } else {
        if (sch$m2_end[d] + L <= DAY_LEN) return(list(day=d, machine="m2"))
      }
    }
  } else {
    # new: choose earliest day; within day choose machine that fits and yields earlier planned time
    for (d in earliest_day:length(sch$m1_end)) {
      ok1 <- (sch$m1_end[d] + L <= DAY_LEN)
      ok2 <- (sch$m2_end[d] + L <= DAY_LEN)
      if (ok1 || ok2) {
        if (ok1 && ok2) {
          # pick machine with smaller planned end (earlier planned slot start)
          if (sch$m1_end[d] <= sch$m2_end[d]) return(list(day=d, machine="m1"))
          return(list(day=d, machine="m2"))
        } else if (ok1) {
          return(list(day=d, machine="m1"))
        } else {
          return(list(day=d, machine="m2"))
        }
      }
    }
  }
  
  stop("No feasible slot found — increase BUFFER_DAYS or check slot lengths/capacity.")
}

# Add appointment to schedule (planned)
add_to_schedule <- function(sch, day, machine, pt) {
  L <- slot_len_for_type(pt)
  if (machine == "m1") {
    sch$m1_types[[day]] <- c(sch$m1_types[[day]], pt)
    sch$m1_slots[[day]] <- c(sch$m1_slots[[day]], L)
    sch$m1_end[day] <- sch$m1_end[day] + L
  } else {
    sch$m2_types[[day]] <- c(sch$m2_types[[day]], pt)
    sch$m2_slots[[day]] <- c(sch$m2_slots[[day]], L)
    sch$m2_end[day] <- sch$m2_end[day] + L
  }
  sch
}

# Simulate execution of one day for one machine:
# planned slot starts at cumulative planned time (from 0), but actual starts can be delayed by overruns.
simulate_machine_day <- function(pt_vec, slot_vec) {
  # pt_vec: ordered appointment types for the day
  # slot_vec: planned slot lengths (minutes)
  if (length(pt_vec) == 0) {
    return(list(busy=0, overtime=0, last_end=0))
  }
  
  # draw durations for each appointment
  dur <- numeric(length(pt_vec))
  for (i in seq_along(pt_vec)) {
    if (pt_vec[i] == "Type 1") {
      # Normal duration in minutes; truncate at >0
      x <- rnorm(1, mean = mu1, sd = sd1)
      while (!is.finite(x) || x <= 0) x <- rnorm(1, mean = mu1, sd = sd1)
      dur[i] <- x
    } else {
      dur[i] <- sample(t2_emp, size = 1)
    }
  }
  
  # planned start times (minutes from DAY_START)
  planned_start <- c(0, cumsum(slot_vec))[1:length(slot_vec)]
  
  # actual start/end
  actual_start <- numeric(length(dur))
  actual_end <- numeric(length(dur))
  
  for (i in seq_along(dur)) {
    if (i == 1) {
      actual_start[i] <- planned_start[i]
    } else {
      actual_start[i] <- max(planned_start[i], actual_end[i-1])
    }
    actual_end[i] <- actual_start[i] + dur[i]
  }
  
  busy <- sum(dur)
  last_end <- actual_end[length(actual_end)]
  overtime <- max(0, last_end - DAY_LEN)
  
  list(busy=busy, overtime=overtime, last_end=last_end)
}

# Summarise KPIs from simulation outputs
kpi_summary <- function(wait_days, overtime_m1, overtime_m2, busy_m1, busy_m2, backlog) {
  overtime_total <- overtime_m1 + overtime_m2
  util_m1 <- busy_m1 / DAY_LEN
  util_m2 <- busy_m2 / DAY_LEN
  
  tibble(
    wait_mean = mean(wait_days),
    wait_median = median(wait_days),
    wait_p90 = as.numeric(quantile(wait_days, 0.90)),
    wait_p95 = as.numeric(quantile(wait_days, 0.95)),
    wait_max = max(wait_days),
    
    svc_le_1 = mean(wait_days <= 1),
    svc_le_2 = mean(wait_days <= 2),
    svc_le_5 = mean(wait_days <= 5),
    
    ot_mean = mean(overtime_total),
    ot_p95 = as.numeric(quantile(overtime_total, 0.95)),
    ot_prob = mean(overtime_total > 0),
    ot_max = max(overtime_total),
    
    util1_mean = mean(util_m1),
    util2_mean = mean(util_m2),
    util_system = mean((busy_m1 + busy_m2) / (2 * DAY_LEN)),
    
    backlog_mean = mean(backlog),
    backlog_prob = mean(backlog > 0),
    
    imbalance_mean = mean(abs(busy_m1 - busy_m2))
  )
}

# -----------------------------
# 3) ONE FULL REPLICATION (policy = "old" or "new")
# -----------------------------
run_one_rep <- function(policy, cal_dates) {
  n_days_total <- length(cal_dates)
  
  # generate calls for the main month only (first n_workdays), then schedule into cal_dates (main+buffer)
  calls_list <- list()
  for (d in 1:n_workdays) {
    c1 <- gen_calls_one_day(d, lambda1, "Type 1")
    c2 <- gen_calls_one_day(d, lambda2, "Type 2")
    calls_list[[length(calls_list)+1]] <- c1
    calls_list[[length(calls_list)+1]] <- c2
  }
  calls <- bind_rows(calls_list)
  if (nrow(calls) == 0) {
    return(list(
      wait_days = numeric(0),
      overtime_m1 = rep(0, n_workdays),
      overtime_m2 = rep(0, n_workdays),
      busy_m1 = rep(0, n_workdays),
      busy_m2 = rep(0, n_workdays),
      backlog = rep(0, n_workdays)
    ))
  }
  
  # schedule structure
  sch <- init_schedule(n_days_total)
  
  # for waiting time: appointment day index - call day index (working days)
  appt_day <- integer(nrow(calls))
  appt_machine <- character(nrow(calls))
  
  # schedule calls in chronological order (call_day then call_time)
  calls <- calls %>% arrange(call_day, call_time)
  
  for (i in 1:nrow(calls)) {
    pt <- calls$PatientType[i]
    # "cannot be scheduled same day": earliest is next working day
    earliest_day <- calls$call_day[i] + 1
    
    slot <- find_earliest_slot(sch, earliest_day, pt, policy)
    sch <- add_to_schedule(sch, slot$day, slot$machine, pt)
    
    appt_day[i] <- slot$day
    appt_machine[i] <- slot$machine
  }
  
  # waiting time in working days (appt_day - call_day)
  wait_days <- appt_day - calls$call_day
  
  # simulate execution for each day in the MAIN month (first n_workdays)
  overtime_m1 <- rep(0, n_workdays)
  overtime_m2 <- rep(0, n_workdays)
  busy_m1 <- rep(0, n_workdays)
  busy_m2 <- rep(0, n_workdays)
  
  for (d in 1:n_workdays) {
    res1 <- simulate_machine_day(sch$m1_types[[d]], sch$m1_slots[[d]])
    res2 <- simulate_machine_day(sch$m2_types[[d]], sch$m2_slots[[d]])
    
    overtime_m1[d] <- res1$overtime
    overtime_m2[d] <- res2$overtime
    busy_m1[d] <- res1$busy
    busy_m2[d] <- res2$busy
  }
  
  # backlog at end of each main day: number of calls up to day d not yet scheduled by day d+1?
  # Simple backlog proxy: number of appointments scheduled after day d for calls <= d
  backlog <- rep(0, n_workdays)
  for (d in 1:n_workdays) {
    backlog[d] <- sum(calls$call_day <= d & appt_day > d)
  }
  
  list(
    wait_days = wait_days,
    overtime_m1 = overtime_m1,
    overtime_m2 = overtime_m2,
    busy_m1 = busy_m1,
    busy_m2 = busy_m2,
    backlog = backlog
  )
}

# -----------------------------
# 4) RUN MONTE CARLO FOR BOTH POLICIES
# -----------------------------
start_date <- min(workdays$Date_parsed)
cal_dates <- make_workday_calendar(start_date, n_workdays, BUFFER_DAYS)

simulate_policy <- function(policy) {
  wait_all <- numeric(0)
  ot1_all <- numeric(0)
  ot2_all <- numeric(0)
  b1_all <- numeric(0)
  b2_all <- numeric(0)
  back_all <- numeric(0)
  
  for (r in 1:N_REP) {
    out <- run_one_rep(policy, cal_dates)
    
    wait_all <- c(wait_all, out$wait_days)
    ot1_all <- c(ot1_all, out$overtime_m1)
    ot2_all <- c(ot2_all, out$overtime_m2)
    b1_all <- c(b1_all, out$busy_m1)
    b2_all <- c(b2_all, out$busy_m2)
    back_all <- c(back_all, out$backlog)
  }
  
  kpi_summary(wait_all, ot1_all, ot2_all, b1_all, b2_all, back_all)
}

cat("Running simulation...\n")
kpi_old <- simulate_policy("old")
kpi_new <- simulate_policy("new")

# -----------------------------
# 5) OUTPUT COMPARISON TABLE
# -----------------------------
comparison <- bind_rows(
  kpi_old %>% mutate(policy = "Old"),
  kpi_new %>% mutate(policy = "New")
) %>%
  select(policy, everything())

print(comparison)

# Optional: show delta (New - Old)
delta <- kpi_new - kpi_old
delta$policy <- "Delta(New-Old)"
delta <- delta %>% select(policy, everything())
print(delta)
